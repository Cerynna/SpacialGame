<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      canvas {
        background: url("img/textures/espace.jpg") no-repeat;
        background-size: cover;
      }
    </style>
  </head>

  <body style="margin: 0px; overflow: hidden; text-align:center;">
    test Galaxy
    <button onclick="ResetCam()">RESET</button>

    <script src="js/three.min.js"></script>
    <script src="js/controls.js"></script>
    <script>
      function rotateSphere(object, speed, delta = 2) {
        // object.rotation.x -= speed * x;
        object.rotation.y -= speed * delta;
        // object.rotation.z -= speed * z;
      }

      function getRandomArbitrary(min, max) {
        return Math.random() * (max - min) + min;
      }

      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function generateCoord() {
        let random = getRandomInt(5, 10) * 100;
        // console.log("RANDOM", ((Math.random() * 10) / 5))
        let theta = getRandomInt(1, 3) * Math.PI * getRandomArbitrary(0, 2);
        let phi = Math.acos(1 - getRandomInt(1, 3) * getRandomArbitrary(0, 2));
        let x = Math.sin(phi) * Math.cos(theta) * random;
        let y = Math.sin(phi) * Math.sin(theta) * random;
        let z = Math.cos(phi) * random;
        return {
          x: x,
          y: y,
          z: z
        };
      }

      var rgbToHex = function(rgb) {
        var hex = Number(rgb).toString(16);
        if (hex.length < 2) {
          hex = "0" + hex;
        }
        return hex;
      };

      function getGalaxy(size = 2) {
        let Planetes = [];

        let nbPlanetes = size * 20;
        let moyenIron = 0;
        let moyenElec = 0;
        let moyenMoney = 0;

        for (let index = 0; index < nbPlanetes; index++) {
          const randomValue = random_rgba();
          let construct = [
            {
              type: "atack",
              player: null
            },
            {
              type: "explo",
              player: null
            },
            {
              type: "commerce",
              player: null
            },
            {
              type: "megapole",
              player: null
            }
          ];
          const size = Math.floor((Math.random() + 1) * 10) * 1.8;

          const position = generateCoord();
          // console.log(Math.floor(position.x + position.y + position.z));
          const Planete = {
            name: Math.floor(position.x + position.y + position.z),
            size: size,
            position: position,
            color: randomValue.rgb,
            construct: construct,
            texture: getRandomInt(0, 29),
            connect: false,
            value: {
              fer: Math.floor((randomValue.red * size) / 8),
              elec: Math.floor((randomValue.blue * size) / 8),
              money: Math.floor((randomValue.green * size) / 20)
            }
          };
          moyenIron += Math.floor((randomValue.red * size) / 8);
          moyenElec += Math.floor((randomValue.blue * size) / 8);
          moyenMoney += Math.floor((randomValue.green * size) / 20);
          Planetes.push(Planete);
        }

        console.log(Planetes.length);

        return Planetes;
      }

      function random_rgba() {
        const o = Math.round;
        const r = Math.random;
        const s = 255;
        const red = o(r() * s);
        const green = o(r() * s);
        const blue = o(r() * s);

        const rgb = "rgb(" + red + "," + green + "," + blue + ")";

        return {
          red: red,
          green: green,
          blue: blue,
          rgb: rgb
        };
      }
      const Galaxy = getGalaxy(10);
      //////////////////////////////////////////////////////////////////////////////////
      //		Init
      //////////////////////////////////////////////////////////////////////////////////
      // init renderer
      var renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      // renderer.setClearColor(new THREE.Color("white"), 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const objects = [];
      const objectsClouds = [];

      // array of functions for the rendering loop
      var onRenderFcts = [];
      // init scene and camera
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        1000,
        window.innerWidth / window.innerHeight,
        0.01,
        10000
      );
      camera.position.z = 2;
      var controls = new THREE.OrbitControls(camera);
      // console.log(controls);

      controls.minDistance = 60;
      // controls.maxDistance = 60;

      var loader = new THREE.TextureLoader();

      Galaxy.forEach(data => {
        const randTexture = Math.floor(Math.random() * 14);
        loader.load(`img/textures/planets/${data.texture}.jpg`, function(
          texture
        ) {
          var geometry = new THREE.SphereGeometry(data.size, 30, 30);
          var material = new THREE.MeshBasicMaterial({
            map: texture,
            // color: data.color,
            wireframe: false
          });
          // material.side = THREE.DoubleSide;
          var sphere = new THREE.Mesh(geometry, material);
          // console.log(sphere);
          sphere.position.x = data.position.x;
          sphere.position.y = data.position.y;
          sphere.position.z = data.position.z;
          sphere.cursor = "pointer";
          sphere.data = data;
          // console.log(sphere);
          scene.add(sphere);
          objects.push(sphere);
        });

        loader.load(`img/textures/clouds/${getRandomInt(0, 3)}.png`, function(
          texture
        ) {
          // var geometry = new THREE.SphereBufferGeometry( 200, 20, 20 );
          // var material = new THREE.MeshLambertMaterial( { map: texture } );
          // var mesh = new THREE.Mesh( geometry, material );
          // group.add( mesh );

          var geometry = new THREE.SphereGeometry(
            data.size + getRandomInt(50, 100) / 100,
            30,
            30
          );
          var material = new THREE.MeshBasicMaterial({
            map: texture,
            color: data.color,
            transparent: true,
            opacity: 0.9,
            wireframe: false
          });
          var sphere = new THREE.Mesh(geometry, material);
          // console.log(sphere);
          sphere.position.x = data.position.x;
          sphere.position.y = data.position.y;
          sphere.position.z = data.position.z;
          sphere.cursor = "pointer";
          sphere.data = data;
          // console.log(sphere);
          // console.log(data.color);

          scene.add(sphere);
          objectsClouds.push(sphere);
        });
      });
      // loader.load("http://localhost:1337/img/textures/10.jpg", function(
      //   texture
      // ) {
      //   var geometry = new THREE.SphereGeometry(900, 100, 100);
      //   var material = new THREE.MeshBasicMaterial({
      //       // map: texture,
      //     color: 0x000000,
      //     wireframe: false
      //   });
      //   var sphere = new THREE.Mesh(geometry, material);
      //   console.log(sphere);
      //   sphere.position.x = 0;
      //   sphere.position.y = 0;
      //   sphere.position.z = 0;
      //   scene.add(sphere);
      //   //   objects.push(sphere);
      // });
      // var geometry = new THREE.SphereGeometry(0.01, 10, 10);
      // var material = new THREE.MeshBasicMaterial({
      //   color: 0xff0000,
      //   wireframe: false
      // });
      // var sphere = new THREE.Mesh(geometry, material);
      // console.log(sphere);
      // sphere.position.x = 0.2;
      // sphere.position.y = 0.1;
      // sphere.position.z = 0.2;
      // sphere.cursor = "pointer";
      // scene.add(sphere);
      // objects.push(sphere);

      // var geometry = new THREE.SphereGeometry(0.01, 10, 10);
      // var material = new THREE.MeshBasicMaterial({
      //   color: 0xffffff,
      //   wireframe: false
      // });
      // var sphere = new THREE.Mesh(geometry, material);
      // console.log(sphere);
      // //   sphere.position.x = 1
      // //   sphere.position.y = 1
      // //   sphere.position.z = 1
      // sphere.cursor = "pointer";
      // scene.add(sphere);
      // objects.push(sphere);

      //   var geometry = new THREE.SphereGeometry(1, 10, 10);
      //   var material = new THREE.MeshBasicMaterial({
      //     color: 0xffff00,
      //     wireframe: true
      //   });
      //   var sphere = new THREE.Mesh(geometry, material);
      //   console.log(sphere);
      //   scene.add(sphere);

      /////////////////////////////////////////////////////
      //		render the whole thing on the page
      //////////////////////////////////////////////////////////////////////////////////
      // handle window resize
      window.addEventListener(
        "resize",
        function() {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        },
        false
      );

      var raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();

      function onDocumentMouseDown(event) {
        // event.preventDefault();

        // console.log("CLICK");

        var rect = renderer.domElement.getBoundingClientRect();
        mouse.x =
          ((event.clientX - rect.left) / (rect.width - rect.left)) * 2 - 1;
        mouse.y =
          -((event.clientY - rect.top) / (rect.bottom - rect.top)) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        intersects = raycaster.intersectObjects(objects);
        // var intersects = raycaster.intersectObjects(scene.children, true);
        // console.log(raycaster);
        if (intersects.length > 0) {
          // console.log(
          //   intersects[0].object.position.x,
          //   intersects[0].object.position.y,
          //   intersects[0].object.position.z
          // );

          // camera.lookAt( intersects[0].object );

          // console.log(controls.center.x);
          // console.log(camera);
          if (
            controls.center.x !== intersects[0].object.position.x ||
            controls.center.y !== intersects[0].object.position.y ||
            controls.center.z !== intersects[0].object.position.z
          ) {
            camera.position.set(0, 0, 0);
            controls.maxDistance = 60;
            setTimeout(() => {
              controls.maxDistance = 3000;
            }, 500);
          }
          controls.center.set(
            intersects[0].object.position.x,
            intersects[0].object.position.y,
            intersects[0].object.position.z
          );

          // controls.maxDistance = 1000;

          controls.update();
        }
      }

      // render the scene
      onRenderFcts.push(function() {
        renderer.render(scene, camera);
      });

      // run the rendering loop
      var lastTimeMsec = null;
      requestAnimationFrame(function animate(nowMsec) {
        objects.forEach(sphere => {
          rotateSphere(sphere, sphere.data.size / 100000);
        });

        objectsClouds.forEach(sphere => {
          rotateSphere(sphere, getRandomInt(0, 2) / 1000, getRandomInt(0, 2));
        });

        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function(onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
      });

      function ResetCam() {
        controls.center.set(0, 0, 0);
        controls.minDistance = 60;
        controls.maxDistance = Infinity;
        controls.update();
      }

      // document.addEventListener("mousemove", onDocumentMouseDown, false);
      document.addEventListener("mousedown", onDocumentMouseDown, false);
    </script>
  </body>
</html>
