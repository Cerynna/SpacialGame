<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body style="margin: 0px; overflow: hidden; text-align:center;">
    test Galaxy

    <script src="js/three.min.js"></script>
    <script src="js/controls.js"></script>
    <script>
      function generateCoord() {
        let theta = 2 * Math.PI * ((Math.random() * 11) / 10);
        let phi = Math.acos(1 - 2 * ((Math.random() * 11) / 10));
        let x = Math.sin(phi) * Math.cos(theta) * 1000;
        let y = Math.sin(phi) * Math.sin(theta) * 1000;
        let z = Math.cos(phi) * 1000;
        return { x: x, y: y, z: z };
      }

      var rgbToHex = function(rgb) {
        var hex = Number(rgb).toString(16);
        if (hex.length < 2) {
          hex = "0" + hex;
        }
        return hex;
      };

      function getGalaxy(size = 2) {
        let Planetes = [];

        let nbPlanetes = size * 40;
        let moyenIron = 0;
        let moyenElec = 0;
        let moyenMoney = 0;

        for (let index = 0; index < nbPlanetes; index++) {
          const randomValue = random_rgba();
          let construct = [
            {
              type: "atack",
              player: null
            },
            {
              type: "explo",
              player: null
            },
            {
              type: "commerce",
              player: null
            },
            {
              type: "megapole",
              player: null
            }
          ];
          const size = Math.floor((Math.random() + 1) * 10);
          const position = generateCoord();
          const Planete = {
            name: "A",
            size: size,
            position: position,
            color: randomValue.rgb,
            construct: construct,
            connect: false,
            value: {
              fer: Math.floor((randomValue.red * size) / 8),
              elec: Math.floor((randomValue.blue * size) / 8),
              money: Math.floor((randomValue.green * size) / 20)
            }
          };
          moyenIron += Math.floor((randomValue.red * size) / 8);
          moyenElec += Math.floor((randomValue.blue * size) / 8);
          moyenMoney += Math.floor((randomValue.green * size) / 20);
          Planetes.push(Planete);
        }
        return Planetes;
      }
      function random_rgba() {
        const o = Math.round;
        const r = Math.random;
        const s = 255;
        const red = o(r() * s);
        const green = o(r() * s);
        const blue = o(r() * s);

        const rgb = "rgb(" + red + "," + green + "," + blue + ")";

        return {
          red: red,
          green: green,
          blue: blue,
          rgb: rgb
        };
      }
      const Galaxy = getGalaxy();
      //////////////////////////////////////////////////////////////////////////////////
      //		Init
      //////////////////////////////////////////////////////////////////////////////////
      // init renderer
      var renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setClearColor(new THREE.Color("black"), 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const objects = [];

      // array of functions for the rendering loop
      var onRenderFcts = [];
      // init scene and camera
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        100,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.z = 2;
      var controls = new THREE.OrbitControls(camera);
      // console.log(controls);

      controls.minDistance = 0;
      controls.maxDistance = 0.01;

      var loader = new THREE.TextureLoader();

      Galaxy.forEach(data => {
        // console.log(data.size / 2000);
        // let color = `0x${rgbToHex()}`;

        loader.load("http://localhost:1337/img/1.png", function(
          texture
        ) {
          // var geometry = new THREE.SphereBufferGeometry( 200, 20, 20 );
          // var material = new THREE.MeshLambertMaterial( { map: texture } );
          // var mesh = new THREE.Mesh( geometry, material );
          // group.add( mesh );

          var geometry = new THREE.SphereGeometry(data.size, 20, 20);
          var material = new THREE.MeshBasicMaterial({
            color: data.color,
            wireframe: false
          });
          var sphere = new THREE.Mesh(geometry, material);
          // console.log(sphere);
          sphere.position.x = data.position.x;
          sphere.position.y = data.position.y;
          sphere.position.z = data.position.z;
          sphere.cursor = "pointer";
          scene.add(sphere);
          objects.push(sphere);
        });
      });

      // var geometry = new THREE.SphereGeometry(10, 10, 10);
      // var material = new THREE.MeshBasicMaterial({
      //   color: 0x000000,
      //   wireframe: false
      // });
      // var sphere = new THREE.Mesh(geometry, material);
      // console.log(sphere);
      // sphere.position.x = 0;
      // sphere.position.y = 0;
      // sphere.position.z = 0;
      // scene.add(sphere);
      // objects.push(sphere);

      // var geometry = new THREE.SphereGeometry(0.01, 10, 10);
      // var material = new THREE.MeshBasicMaterial({
      //   color: 0xff0000,
      //   wireframe: false
      // });
      // var sphere = new THREE.Mesh(geometry, material);
      // console.log(sphere);
      // sphere.position.x = 0.2;
      // sphere.position.y = 0.1;
      // sphere.position.z = 0.2;
      // sphere.cursor = "pointer";
      // scene.add(sphere);
      // objects.push(sphere);

      // var geometry = new THREE.SphereGeometry(0.01, 10, 10);
      // var material = new THREE.MeshBasicMaterial({
      //   color: 0xffffff,
      //   wireframe: false
      // });
      // var sphere = new THREE.Mesh(geometry, material);
      // console.log(sphere);
      // //   sphere.position.x = 1
      // //   sphere.position.y = 1
      // //   sphere.position.z = 1
      // sphere.cursor = "pointer";
      // scene.add(sphere);
      // objects.push(sphere);

      //   var geometry = new THREE.SphereGeometry(1, 10, 10);
      //   var material = new THREE.MeshBasicMaterial({
      //     color: 0xffff00,
      //     wireframe: true
      //   });
      //   var sphere = new THREE.Mesh(geometry, material);
      //   console.log(sphere);
      //   scene.add(sphere);

      /////////////////////////////////////////////////////
      //		render the whole thing on the page
      //////////////////////////////////////////////////////////////////////////////////
      // handle window resize
      window.addEventListener(
        "resize",
        function() {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        },
        false
      );

      var raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      function onDocumentMouseDown(event) {
        // event.preventDefault();

        console.log("CLICK");

        var rect = renderer.domElement.getBoundingClientRect();
        mouse.x =
          ((event.clientX - rect.left) / (rect.width - rect.left)) * 2 - 1;
        mouse.y =
          -((event.clientY - rect.top) / (rect.bottom - rect.top)) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        intersects = raycaster.intersectObjects(objects);
        // var intersects = raycaster.intersectObjects(scene.children, true);
        // console.log(raycaster);
        console.log(intersects);
        console.log(camera);
      }

      // render the scene
      onRenderFcts.push(function() {
        renderer.render(scene, camera);
      });

      // run the rendering loop
      var lastTimeMsec = null;
      requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function(onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
      });

      document.addEventListener("mousedown", onDocumentMouseDown, false);
    </script>
  </body>
</html>
